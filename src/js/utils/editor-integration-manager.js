/**\n * Editor Integration Manager\n * 编辑器和主题编辑器协同工作管理器\n * \n * 主要功能：\n * - 同步主题变更到主编辑器\n * - 处理编辑器和主题编辑器间的通信\n * - 管理全局状态同步\n */\nwindow.EditorIntegrationManager = {\n    // 事件监听器跟踪\n    listeners: new Map(),\n    \n    // 当前活动的编辑器引用\n    activeEditor: null,\n    \n    // 主题变更回调队列\n    themeChangeCallbacks: new Set(),\n\n    /**\n     * 初始化协同管理器\n     */\n    init() {\n        this.setupThemeChangeListener();\n        this.setupEditorSyncEvents();\n        window.Logger.debug('EditorIntegrationManager initialized');\n    },\n\n    /**\n     * 设置主题变更监听器\n     */\n    setupThemeChangeListener() {\n        // 监听主题服务的变更事件\n        if (window.themeService && window.themeService.on) {\n            window.themeService.on('themeChanged', (theme) => {\n                this.onThemeChanged(theme);\n            });\n        }\n        \n        // 设置定期检查主题变更（备用方案）\n        this.lastActiveThemeId = window.themeService ? window.themeService.getActiveTheme()?.id : null;\n        this.themeCheckInterval = setInterval(() => {\n            this.checkThemeChanges();\n        }, 1000);\n    },\n\n    /**\n     * 检查主题变更（轮询方式）\n     */\n    checkThemeChanges() {\n        if (!window.themeService) return;\n        \n        const currentTheme = window.themeService.getActiveTheme();\n        const currentThemeId = currentTheme?.id;\n        \n        if (currentThemeId !== this.lastActiveThemeId) {\n            this.lastActiveThemeId = currentThemeId;\n            this.onThemeChanged(currentTheme);\n        }\n    },\n\n    /**\n     * 处理主题变更事件\n     */\n    onThemeChanged(theme) {\n        window.Logger.debug('Theme changed, syncing to editors', theme?.name);\n        \n        // 同步到主编辑器\n        this.syncThemeToMainEditor(theme);\n        \n        // 执行注册的回调\n        this.themeChangeCallbacks.forEach(callback => {\n            try {\n                callback(theme);\n            } catch (error) {\n                window.Logger.error('Theme change callback failed', error);\n            }\n        });\n    },\n\n    /**\n     * 同步主题到主编辑器\n     */\n    syncThemeToMainEditor(theme) {\n        if (!theme || !window.EditorView || !window.EditorView.quillInstance) {\n            return;\n        }\n\n        try {\n            const editor = window.EditorView.quillInstance;\n            const editorRoot = editor.root;\n            \n            // 应用主题样式到编辑器\n            if (theme.styles) {\n                // 设置编辑器字体样式\n                const fontSize = theme.styles['--p-font-size'] || '16px';\n                const fontFamily = theme.styles['--p-font-family'] || 'sans-serif';\n                const textColor = theme.styles['--p-color'] || '#333';\n                const lineHeight = theme.styles['--p-line-height'] || '1.7';\n                \n                editorRoot.style.fontSize = fontSize;\n                editorRoot.style.fontFamily = fontFamily;\n                editorRoot.style.color = textColor;\n                editorRoot.style.lineHeight = lineHeight;\n                \n                // 更新编辑器内的标题样式\n                const h1Elements = editorRoot.querySelectorAll('h1');\n                h1Elements.forEach(h1 => {\n                    h1.style.color = theme.styles['--h1-color'] || textColor;\n                    h1.style.fontSize = theme.styles['--h1-font-size'] || '24px';\n                });\n                \n                const h2Elements = editorRoot.querySelectorAll('h2');\n                h2Elements.forEach(h2 => {\n                    h2.style.color = theme.styles['--h2-color'] || textColor;\n                    h2.style.fontSize = theme.styles['--h2-font-size'] || '20px';\n                });\n                \n                const h3Elements = editorRoot.querySelectorAll('h3');\n                h3Elements.forEach(h3 => {\n                    h3.style.color = theme.styles['--h3-color'] || textColor;\n                    h3.style.fontSize = theme.styles['--h3-font-size'] || '18px';\n                });\n            }\n            \n            // 更新主题显示\n            if (window.EditorView.updateThemeDisplay) {\n                window.EditorView.updateThemeDisplay();\n            }\n            \n            window.Logger.debug('Theme synced to main editor successfully');\n        } catch (error) {\n            window.Logger.error('Failed to sync theme to main editor', error);\n        }\n    },\n\n    /**\n     * 设置编辑器同步事件\n     */\n    setupEditorSyncEvents() {\n        // 监听编辑器内容变更，重新应用样式\n        if (window.EditorView) {\n            this.registerThemeChangeCallback((theme) => {\n                // 延迟应用，确保DOM更新完成\n                setTimeout(() => {\n                    this.syncThemeToMainEditor(theme);\n                }, 100);\n            });\n        }\n    },\n\n    /**\n     * 注册主题变更回调\n     */\n    registerThemeChangeCallback(callback) {\n        if (typeof callback === 'function') {\n            this.themeChangeCallbacks.add(callback);\n            return () => {\n                this.themeChangeCallbacks.delete(callback);\n            };\n        }\n    },\n\n    /**\n     * 设置活动编辑器引用\n     */\n    setActiveEditor(editor) {\n        this.activeEditor = editor;\n        window.Logger.debug('Active editor set', editor?.constructor?.name);\n    },\n\n    /**\n     * 触发主题重新应用\n     */\n    refreshTheme() {\n        const currentTheme = window.themeService ? window.themeService.getActiveTheme() : null;\n        if (currentTheme) {\n            this.onThemeChanged(currentTheme);\n        }\n    },\n\n    /**\n     * 获取集成状态\n     */\n    getStatus() {\n        return {\n            isInitialized: !!this.themeCheckInterval,\n            activeEditor: this.activeEditor?.constructor?.name || null,\n            callbackCount: this.themeChangeCallbacks.size,\n            lastThemeId: this.lastActiveThemeId\n        };\n    },\n\n    /**\n     * 清理资源\n     */\n    cleanup() {\n        // 清理定时器\n        if (this.themeCheckInterval) {\n            clearInterval(this.themeCheckInterval);\n            this.themeCheckInterval = null;\n        }\n        \n        // 清理回调\n        this.themeChangeCallbacks.clear();\n        \n        // 清理监听器\n        this.listeners.forEach((listener, key) => {\n            // 这里可以添加具体的清理逻辑\n        });\n        this.listeners.clear();\n        \n        this.activeEditor = null;\n        \n        window.Logger.debug('EditorIntegrationManager cleaned up');\n    }\n};\n\n// 页面卸载时清理\nwindow.addEventListener('beforeunload', () => {\n    if (window.EditorIntegrationManager) {\n        window.EditorIntegrationManager.cleanup();\n    }\n});